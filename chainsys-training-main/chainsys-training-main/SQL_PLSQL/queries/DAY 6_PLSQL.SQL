-- 1 PRIVATE PROCEDURE/FUNCTIONS IN PACKAGE
DROP PACKAGE BODY TEST_PKG;
DROP PACKAGE TEST_PKG;
CREATE OR REPLACE PACKAGE TEST_PKG AS
    PROCEDURE TEST_PROC1;
    PROCEDURE TEST_PROC2;
END;

CREATE OR REPLACE PACKAGE BODY TEST_PKG
AS
    -- PRIVATE PROCEDURE
    PROCEDURE TEST_PROC3 AS
    BEGIN
        DBMS_OUTPUT.PUT_LINE('PROC3');
    END;
    PROCEDURE TEST_PROC1 AS
    BEGIN
        DBMS_OUTPUT.PUT_LINE('PROC1');
        TEST_PROC3;
    END;
    PROCEDURE TEST_PROC2 AS
    BEGIN
        DBMS_OUTPUT.PUT_LINE('PROC2');
        TEST_PROC3;
    END;
END;

EXEC TEST_PKG.TEST_PROC1;
EXEC TEST_PKG.TEST_PROC2;
EXEC TEST_PKG.TEST_PROC3;

-- TRIGGER
CREATE TABLE audits (
      audit_id         NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      table_name       VARCHAR2(255), -- where
      transaction_name VARCHAR2(10), -- what
      by_user          VARCHAR2(30), -- who
      transaction_date DATE -- when
);
select * from audits;
-- 2 CREATE ROW LEVEL TRIGGER
CREATE OR REPLACE TRIGGER customers_audit_trg
    AFTER 
    UPDATE OR DELETE 
    ON customer_REFERENCE_INFO
   -- FOR EACH ROW    
DECLARE
   l_transaction VARCHAR2(10);
BEGIN
   -- determine the transaction type
   l_transaction := 
   CASE  
         WHEN UPDATING THEN 'UPDATE'
         WHEN DELETING THEN 'DELETE'
   END;

   -- insert a row into the audit table   
   INSERT INTO audits (table_name, transaction_name, by_user, transaction_date)
   VALUES('CUSTOMER_personal_info', l_transaction, USER, SYSDATE);
END;
-- show user;

UPDATE CUSTOMER_REFERENCE_INFO
SET RELATION='NEIGHBOUR';
-- WHERE CUSTOMER_ID='C-001';

DELETE FROM CUSTOMER_REFERENCE_INFO;
-- WHERE CUSTOMER_ID='C-001';
-- INSERT INTO CUSTOMER_REFERENCE_INFO(CUSTOMER_ID,REFERENCE_ACC_NAME,REFERENCE_ACC_NO,REFERENCE_ACC_ADDRESS,RELATION) VALUES('C-001','RAM',0987654321122345,'NO.11,BRIGRADE ROAD,BANGALORE','FRIEND');

ROLLBACK;
SELECT * FROM CUSTOMER_REFERENCE_INFO;
SELECT * FROM AUDITS;

-- 3 STATEMENT LEVEL TRIGGER
CREATE OR REPLACE TRIGGER customers_credit_trg
    BEFORE UPDATE OF REFERENCE_ACC_ADDRESS  
    ON customer_REFERENCE_INFO
DECLARE
    l_day_of_month NUMBER;
BEGIN
    -- determine the transaction type
    l_day_of_month := EXTRACT(DAY FROM sysdate);

    IF l_day_of_month BETWEEN 28 AND 31 THEN
        raise_application_error(-20100,'Cannot update customer detail from 28th to 31st');
    END IF;
END;
UPDATE CUSTOMER_REFERENCE_INFO
SET REFERENCE_ACC_ADDRESS='CHENNAI';
ROLLBACK;
COMMIT;
-- TO DISPLAY USER
SHOW USER;
-- 4 DDL TRIGGER
DROP TABLE SCHEMA_AUDIT;
CREATE TABLE SCHEMA_AUDIT
(
 DDL_DATE DATE,-- when
 DDL_USER VARCHAR2(15),--who
 OBJECT_CREATED VARCHAR2(15),--what object
 OBJECT_NAME VARCHAR2(15),-- what object name
 DDL_OPERATION VARCHAR2(15)-- ddl
);
drop trigger USER_AUDIT_TR;
CREATE OR REPLACE TRIGGER USER_AUDIT_TR
AFTER DDL ON SCHEMA
BEGIN 
    INSERT INTO SCHEMA_AUDIT 
    VALUES(SYSDATE,USER,ORA_DICT_OBJ_TYPE,ORA_DICT_OBJ_NAME,ORA_SYSEVENT);
END;
ALTER TRIGGER USER_AUDIT_TR DISABLE;
ALTER TRIGGER USER_AUDIT_TR ENABLE;

SELECT * FROM SCHEMA_AUDIT;
CREATE TABLE DUMMY(ID NUMBER);
INSERT INTO DUMMY VALUES(1);
SELECT * FROM DUMMY;
TRUNCATE TABLE DUMMY;
DESC DUMMY;
DROP TABLE DUMMY;
-- EXCEPTION
-- 5 PRE DEFINED EXCEPTION Anonymous Block Handles ZERO_DIVIDE
DECLARE
  stock_price   NUMBER := 9.73;
  net_earnings  NUMBER := 0;
  pe_ratio      NUMBER;
BEGIN
  pe_ratio := stock_price / net_earnings;  -- implicit raises ZERO_DIVIDE exception
  DBMS_OUTPUT.PUT_LINE('Price/earnings ratio = ' || pe_ratio);
EXCEPTION -- exception handler
  WHEN ZERO_DIVIDE THEN
    DBMS_OUTPUT.PUT_LINE('Company had zero earnings.');
    pe_ratio := NULL;
END;
-- 6 PRE DEFINED EXCEPTION
DECLARE
    l_name customer_PERSONAL_INFO.CUSTOMER_NAME%TYPE;
BEGIN
    -- IMPLICITLY RAISED
    -- get the customer 
    SELECT customer_PERSONAL_INFO.CUSTOMER_NAME
    INTO l_name
    FROM customer_PERSONAL_INFO
    WHERE customer_id ='C-111';
    -- WHERE GENDER = 'M'; 
  
    
    -- show the customer name   
    dbms_output.put_line('Customer name is ' || l_name);
    EXCEPTION -- multiple exception handler
        WHEN NO_DATA_FOUND THEN
            dbms_output.put_line('Customer does not exist');
        WHEN TOO_MANY_ROWS THEN
            dbms_output.put_line('The database returns more than one customer');    
END;
-- 7  EXPLICITLY RAISE PREDEFINDED EXCEPTION
DECLARE
    l_customer_id customer_PERSONAL_INFO.customer_id%TYPE := &customer_id;
BEGIN
    IF l_customer_id ='0' THEN
        RAISE invalid_number; -- EXPLICITLY RAISED
    END IF;
    EXCEPTION 
    WHEN INVALID_NUMBER THEN
        dbms_output.put_line('Customer does not exist');
END;
-- 8 USER DEFINED EXCEPTION
DECLARE
    l_name customer_PERSONAL_INFO.CUSTOMER_NAME%TYPE;
    L_GENDER customer_PERSONAL_INFO.GENDER%TYPE:=&GENDER;
    E_INVALID_GENDER EXCEPTION;
    PRAGMA exception_init( E_INVALID_GENDER, -20001 );
BEGIN
    -- IMPLICITLY RAISED
    IF(L_GENDER='M' OR L_GENDER='F') THEN
        -- get the customer 
        SELECT customer_PERSONAL_INFO.CUSTOMER_NAME
        INTO l_name
        FROM customer_PERSONAL_INFO
        WHERE GENDER = L_GENDER; 
    ELSE
       -- RAISE E_INVALID_GENDER;
       raise_application_error(-20001,'INVALID GENDER ERROR');
    END IF;
  
    -- show the customer name   
    dbms_output.put_line('Customer name is ' || l_name);
    EXCEPTION 
--        WHEN E_INVALID_GENDER THEN 
--            dbms_output.put_line('INVALID GENDER');
        WHEN NO_DATA_FOUND THEN
            dbms_output.put_line('Customer does not exist');
        WHEN TOO_MANY_ROWS THEN
            dbms_output.put_line('The database returns more than one customer');    
END;
-- 9 PRAGMA AUTONOMOUS_TRANSACTION
CREATE OR REPLACE PROCEDURE UPDATE_MAIL 
AS
  PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
    UPDATE CUSTOMER_PERSONAL_INFO
    SET MAIL_ID = 'JANANISE@GMAIL.COM'
    WHERE CUSTOMER_ID='C-001';
    ROLLBACK;
END;

BEGIN
    UPDATE CUSTOMER_PERSONAL_INFO
    SET MAIL_ID = 'JAMES_123@GMAIL.COM'
    WHERE CUSTOMER_ID='C-002';
    UPDATE_MAIL;
    COMMIT;
END;